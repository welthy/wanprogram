[TOC]

GC（垃圾回收）作为JVM中的一大重点，是面试高频考题。 

对于GC问题，主要从2方面入手：

- 什么是垃圾，如何标记垃圾
- 怎么清理垃圾

### 什么是垃圾？如何标记？

我们认为，当对象不再被引用指向时，则该对象即认为不再被需要，可以回收。 

故，当对象没有引用指向时，则认为是**垃圾**。 

标记垃圾，通常有2种方式： 

- 计数法：每个对象有唯一的计数器，计数引用的个数，当计数为0时，则认为该对象为垃圾；
- 可达性分析：JVM指定一些对象为ROOT节点，当从ROOT节点出发无法访问到目标对象时，则认为该对象是垃圾；

对于计数法，若有2个对象循环引用彼此，则均不会视为垃圾，故均不会被回收（虽然已经不再使用）。可达性分析法则无该问题。



### 怎么清理垃圾？

垃圾清理有如下几种方式：

#### 标记-清除算法

将内存中被标记为垃圾的对象直接进行清理操作。 

这样清理后，会发现内存中有很多不连续的内存空间，造成浪费。当需要存储大对象时无法找到存储地方，导致不得不触发一次GC。

#### 复制清理

在标记为垃圾的对象，在清理前，首先将它们复制到内存地址边缘地带，然后进行清理。 

#### 标记整理清理

将内存分为几块，如AB两块，使用时始终使用A块，当进行GC时，将垃圾复制到B块，然后清理全部B块。 

#### 分代清理

将内存分为**年轻代**和**老年代**，其中年轻代中对象创建销毁频繁，老年代中对象存活时间较长。对于年轻代可用复制清理方式进行清理，对于老年代则可用标记清理，或标记整理清理方式进行清理。



### 内存划分

上文说了那么多垃圾清理，那么整个内存都要进行清理吗？首先我们需要了解JVM将内存分为哪些部分？分别存储什么？那部分是对象的集中营？

#### 内存划分模型

JVM将内存分为如下几个部分：

- 程序计数器：记录程序执行的位置，线程私有；
- Java虚拟机栈：存储Java方法执行的内存模型，方法执行时会创建栈帧，存储局部变量，操作数栈，方法出口等信息。也是线程私有，生命周期与线程相同；
- 本地方法栈：与虚拟机栈类似，不过虚拟机栈执行的是Java方法，而本地方法栈执行的Native方法；
- 堆：垃圾重灾区，线程共享区域，该部分唯一目的就是存储对象；
- 方法区：线程共享区域，存储加载的类信息，常量，静态变量等信息（常量池属于方法区的一部分）；