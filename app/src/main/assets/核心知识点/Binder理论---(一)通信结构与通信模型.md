[TOC]



# Binder（一）------通信结构与通信模型



## 引言

​        Android的IPC采用的C/S架构，这样的话每个进程可着重关注如何实现自己的独立功能，若需要使用其他进程已实现的功能，则无需自己再实现一遍，可以直接作为调用客户端去访问实现该功能的服务端从而使用其对应功能。例如，要使用视频，音频等功能只需作为客户端去访问实现视频，音频功能接口的进程服务端，然后调用服务端的对应接口方法即可。这样在不破坏每个进程彼此独立的前提下，又提供了一种简单有效的彼此沟通的方式。



## 为什么是Binder

​		由于Android是基于Linux系统开发的操作系统，所以Linux的固有的IPC方式，在Android上也是适用的，但在已有的IPC通信方式中，若要达到上述的C/S架构模式，只有Socket套接字方式才能达到要求，可惜Socket的传输性能较差，通常用于低频的IPC通信。基于此，在Android上实现了一套名为**“Binder”**的机制用于在Android系统上进行IPC通信。

​		那么Binder为何被选中作为Android的IPC机制呢？上述说到，Linux原本支持的IPC中只有Socket采用的是C/S架构，但性能不好，故Binder的主要优势之一就是性能良好。所以可以说：**Binder**是一种**基于C/S架构**，**有着良好通信性能**，**独存于Android系统中**的，**一种IPC方式**（故意这么分开是为了点亮Binder的特点）。

### 传输性能

​		说到性能的话，我们可以从传输性能，安全性能方面说起。

​		由于Linux对于进程有着沙盒机制，即每个进程被“沙盒”封装起来，进程间彼此独立，这样当一个进程崩溃的话，其他进程仍可以正常运行，系统仍能正常运行，算是系统提供的一种保护机制。但有时需要进程间传递数据，进行通信，那么就提供了一系列的IPC方式，如：管道，共享内存，消息队列，信号量和Socket，以及我们本文的Binder。既然有这么多种IPC方式，自然有好有坏，又因为Binder是Android系统独立设计的，那么它一定是最"优秀"的。

​		有一个前提基础是：Linux系统中，进程间通信都需要经过Linux内核，在内核中可直接进行通信，否则就做不到进程间的通信需求。

​		**所以在进行IPC操作时，就避免不了用户空间的数据与内核空间的传递过程。** 各种IPC中（暂不提Binder），除共享内存外，其余方式都至少需要拷贝2次（本地进程用户空间拷贝至内核空间，再从内核空间拷贝至目标进程的用户空间。共享内存无需拷贝）。详情可见下表：

| IPC方式                     | 拷贝次数 |
| --------------------------- | -------- |
| 共享内存                    | 0        |
| Binder                      | 1        |
| 管道/消息队列/信号量/Socket | 2        |

为什么Binder只需一次呢？因为Binder在Linux内核空间独立出了一块区域，可直接读取服务端数据，只需要客户端将数据拷贝至此处即可。

​		由上可看到，传输次数减少了，带来的资源消耗就少了，从而加大了传输性能。

简述之：**Binder相对而言减少了数据拷贝次数达到提高传输性能的目的。**

### 安全性能

​		那么，为什么Binder更具安全性呢？纵观其他的IPC方式，我们无法得知请求进行通信的请求方是否合法（满足要求），即无论是谁，只要搭上了这条链路，就能进行数据交换。为了识别请求方，Binder对每个进程都分配了UID/PID，当通过Binder进行IPC时，系统会去核对UID/PID是否合法，只要系统认为合法的PID，才能搭上Binder的车。如此，在IPC上增加一道关卡，保障IPC通信安全，所以相对其他IPC方式更具安全性。

简述之：**Binder通过UID/PID来保证通信双方的合法性，进而达到IPC间消息传输的安全性。**



## Binder通信模型

​		Binder既然采用的是C/S架构，那么就会定义客户端与服务端。但由于每个进程既可以是客户端也可以是服务端，且Android系统中将包含大量的服务端，因此Binder系统中包括如下几个成员：

​		**Server**（服务端），**Client**（客户端），**ServiceManager**（服务端与客户端的管理者）和**Binder**驱动（进行实际通信操作）。

### **Binder驱动**

​		Binder驱动，虽然叫驱动，但并不是真正的硬件驱动，而只是实现了驱动效果的一套代码而已。并且它运行在内核区，因此它是真正达到IPC效果的地方。

​		上述说到，它实现了驱动效果，即实现驱动的一些方法如epoll()什么的。使用起来和真正的操作驱动并未差别。

### Server和Server中的Binder 

​		Server作为Binder架构中服务端，是提供功能的一端，在Server服务端中，Binder是以实体存在于服务端中，客户端获得的是Binder实体的**引用**，可以说指针或句柄，都是一个意思，因为是Android开发者，说引用的话比较好理解。客户端拿到该引用后，就可调用服务端中Binder暴露出来的接口，通过调用这些接口达到客户端获取服务端数据的操作。

### Client和Client中的Binder

​		Client作为Binder架构中的客户端，是调用功能的一端，其拿到的Binder并非是Binder实体，而是指向该Binder实体的引用。

### ServiceManager和ServiceManager中的Binder 

​		Android系统中存在了大量的服务端，作为客户端的我虽然知道谁手握我需要的功能，但我该如何去拿到这个服务端Binder的引用，进而去调用对应的功能呢？ServiceManager为此而生。

​		ServiceManager存储了Binder名称和Binder实体的对应关系表。类似于域名和IP的对应关系。当有新的Service时，需要向ServiceManager进行注册，因此系统中含有的服务端Binder都能从ServiceManager中查找到，那么作为客户端只需拿着Binder的名称去咨询ServiceManager即可。但ServiceManager是运行在system_server进程中的，因此，这必然是一次IPC过程，那么在还未搭建IPC桥梁的时候进行IPC必然是自相矛盾的，所以系统将ServiceManager的Binder实体的Binder引用干脆暴露出来，让所有进程都知道其Binder引用是什么，不需要进行查找，直接与ServiceManager通信 。

​		当新的Service向ServiceManager注册后，客户端调用时会在请求体中包含请求的Binder名称，ServiceManager会根据名称找到对应Binder的引用，然后告诉客户端，这样客户端就拿到服务端的Binder引用，然后就可以根据该引用去调用服务端的相关接口方法。





### 特别鸣谢

https://blog.csdn.net/universus/article/details/6211589  --------   **Android Bander设计与实现 - 设计篇**

